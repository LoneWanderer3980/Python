# 可逆数据隐藏
python之再学习
Step1:预测误差计算：
	x的取值范围：图像第一行到倒数第二行，图像第一列至倒数第二列，可存储的数据点比其他算法多。
	1).预测像素：反因果预测器，利用3个上下文像素值进行预测
        
	2).预测误差：真实值减去预测值
	 
Step2:预测误差直方图平移：
	
     
Left0:依次原点左边远离原点的零点绝对值
Right0:依次原点右边远离原点的零点
根据左右零点将图像的外区域分段，分别进行平移
内区域：[-Tn,Tp]，初始化为[0,0]
外区域：[ -left0[k0]+1,-Tn-1],[Tp+1, right0[k1]-1], 初始化为[-left[0]+1,-1],[1,right[0]-1]
假设首次向左移动						假设首次向右移动
[-left0[k0]+1,-Tn-1]左移一位				[Tp+1,right[k1]-1]右移一位
内区域  ->  [-1,0]						内区域  ->  [0,1]
K0++    Tn++							k1++     Tp++
向右移动：								向左移动：
[Tp+1,right0[k1]-1]右移一位				[-left0[k0]+1,-Tn-1]左移一位
内区域  ->  [-1,1]						内区域	->	[-1,1]
K1++    Tp++							k0++	Tn++
左移后移交替进行，直到内区域中可嵌入的像素点大于要隐藏的数据信息、头文件信息、溢出位置信息的长度。
Step3:数据嵌入：
	 
	根据平移得到的数据，将区间分段，对处于不同的段的像素执行不同的平移操作，
	内区域：
原区间	预测误差	变化后区间	像素
溢出点	　	　	　
[-Tn+1,0]	2*Pe-data[i]	[-2*Tn+1,0]	x+Pe-data[i]
(0,Tp]	2*Pe-1+data[i]	(0,2*Tp]	x+Pe+data[i]
	外区域：以左边外区域为例
		第一区间左平移Tn位
第二区间左平移Tn-1位
	.
	.
	.
第Tn区间向左平移1位
Len_m：位置溢出图长度，位置溢出点越多，长度越大
Len_q:头信息长度，预测结束后长度为定值
嵌入隐藏数据后，嵌入顺序扫描的前len_m+len_q个信息。最后用LSB算法将头信息、位置溢出图嵌入前len_m+len_q个信息。
	LSB算法：用需要隐藏的数据直接替换像素点二进制化后的最后一位，提取的时候，直接得到像素二进制化后的最后一位。
Step4:数据恢复
	从头按顺序扫描图片，提取头文件和位置溢出图，得到最后嵌入点坐标后，从该点逆向扫描像素，提取数据并恢复像素。提取的前len_m+len_q个消息，每提取一个就要用LSB算法插入原对应位置的像素。后来得到的数据是逆序的data,要得到原data要记得将数据反向排序。原像素的计算用预测像素加上修改后的预测误差得到。
	处于不同区间段的像素也有不同的恢复方法：
	
原区间		预测误差	   变化后区间	提取数据	　	　	　
[-2*Tn+1,0]	(Pe'+1)//2	[-Tn+1,0]	Pe'%2
(0,2*Tp]	(Pe'+1)//2	(0,Tp]	(Pe'-1)%2
溢出点：
第一区间右平移Tn位
第二区间右平移Tn-1位
	.
	.
	.
第Tn区间向右平移1位
